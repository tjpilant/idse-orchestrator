# Feedback

## External / Internal Feedback
- Internal feedback (2026-02-03 to 2026-02-04): Notion MCP integration and sync troubleshooting while wiring the IDSE Orchestrator to Notion as Artifact Core storage. Feedback was generated by hands-on testing of CLI sync, MCP tool schemas, and Notion database configuration.

## Completion Summary (2026-02-04)
- Repo & self-dogfooding complete
- Phase 1 – Workspace + Pipeline complete
- Phase 2 – Governance complete
- Phase 3 – Sync complete (Notion backend verified)
- Phase 4 – Agent Coordination complete
- Phase 5 – Doc → AgentProfileSpec compiler complete
- Governance & Spine alignment complete

## Impacted Artifacts
- Intent: No changes required.
- Context: Updated understanding of MCP boundaries vs DesignStore responsibilities.
- Spec: Clarified storage backend requirements and Notion schema expectations.
- Plan / Test Plan: Updated operational steps for Notion sync setup/validation.
- Tasks / Implementation: Implemented Notion MCP backend, tooling, and debug flow.

## Risks / Issues Raised
- Notion MCP tool schemas are strict and differ by tool name; incorrect payloads silently fail or drop data.
- `notion-query-database-view` requires `view_url` in `view://<dashed-uuid>` format; HTTPS URLs were rejected.
- Notion select values are case-sensitive; stage values must match configured options.
- Without debug instrumentation, failures can appear as "success" while creating pages in unintended databases or with missing content.

## Actions / Follow-ups
- Confirm Notion database select options remain aligned with stage normalization (Owner: IDSE Orchestrator, Status: ongoing).
- Maintain a known-good Notion schema template for IDSE Artifacts (Owner: IDSE Orchestrator, Status: ongoing).
- Add a lightweight checklist for MCP tool schema verification on new backends (Owner: IDSE Orchestrator, Status: planned).
- Completed hotfix: preserve existing Notion `tool_names` during `idse sync setup` and normalize/store dashed UUID view IDs only (Owner: IDSE Orchestrator, Status: done).

## Decision Log
- Chosen backend behavior: use DesignStore derivatives with MCP tooling rather than giving agents MCP access.
- For Notion sync: use `notion-create-pages` + `notion-update-page` with schema-compliant payloads; avoid `data_source_id` unless explicitly required.
- For stage mapping: normalize to Notion select values (`Intent`, `Context`, `Specification`, `Plan`, `Tasks`, `Test Plan`, `Feedback`).

## Lessons Learned (Verbose)

1) **Notion MCP tool schemas are strict and vary by tool name.**  
   `notion-query-database-view` requires `view_url`, and the accepted format was `view://<dashed-uuid>`. HTTPS view URLs failed.

2) **Database ID vs Data Source ID matters.**  
   For `notion-create-pages`, the correct parent is `parent: { type: "database_id" }` (not `data_source_id`) for this database.

3) **Select values are case-sensitive.**  
   Stage values must match the exact Notion select options. We normalized `intent → Intent`, `spec → Specification`, `implementation → Test Plan`.

4) **Content handling is tool-specific.**  
   `notion-create-pages` accepts a `content` string in Notion Markdown.  
   `notion-update-page` requires `data.command` with `replace_content`.

5) **Visibility depends on view filters.**  
   Pages can exist but be hidden by view filters. Always confirm via raw page URLs returned by MCP.

6) **Debug mode was essential.**  
   Logging payloads and results exposed misaligned schemas and wrong parent types quickly.

## Post-Timeout Resolution (2026-02-10)

The timed-out implementation gap was closed with upstream code changes and tests:

- Fixed stale Notion MCP defaults in package code.
- Fixed setup overwrite behavior so `tool_names` overrides are preserved.
- Fixed view ID formatting by normalizing to dashed UUIDs.
- Prevented malformed `database_view_url` precedence by storing normalized `database_view_id` and letting runtime format view URLs.

Result:
- Setup now generates stable Notion config for current MCP tools.
- Query payloads now use canonical `view://<dashed-uuid>` values.

## Per-Project Config Implementation (2026-02-11)

**Issue**: Global `~/.idseconfig.json` caused cross-project Notion database pollution. When user ran `idse sync setup` for a new project, it loaded the existing global config with database ID from a different project, causing new projects to inherit the wrong Notion database.

**Solution Implemented**: Per-project config with local-first resolution.

**What Worked Well**:
- Simple, familiar pattern (like `.npmrc` or `.gitconfig`)
- Config resolution priority is clear: explicit flag > local > global
- `idse sync setup` prompts for save location, defaults to project-local when `.idse/` exists
- Tests validate all three resolution paths (explicit, local, global)
- Documentation updated in `docs/backends/notion.md`

**Edge Cases Addressed**:
- `.idse/.idseconfig.json` added to `.gitignore` to prevent credentials in version control
- Global fallback preserved for backward compatibility
- Explicit `--config` flag still takes highest priority

**Validation**:
- All 143 tests pass (3 new tests added for config resolution)
- Manual testing confirms local config preferred when present
- Existing global configs continue to work for projects without local config

**Lessons**:
- Per-project config should have been the default from the start — global config for project-specific database IDs was a design smell
- The fix is minimal (25 lines of code) but high-impact for multi-project workflows
- Interactive CLI prompts improve discoverability (`idse sync setup` now guides users to per-project pattern)
